const Canvas = require("canvas");
const jimp = require("jimp");
const gradians = require("../gradiants.json");
class CanvasSenpai {
  async welcome(member, { link, gradiant, blur } = {}) {
    if (blur !== false) {
      blur = true;
    }
    if (link && gradiant) {
      return console.log("You can not use link and gradiant at a same time");
    }

    if (!link) {
      if (gradiant) {
        let color = gradians.find(x => x.name === gradiant.toLowerCase());
        if (!color) {
          return console.log("Invalid Gradiant Color :v");
        }

        link = color.link;
      } else {
        link = "https://coverfiles.alphacoders.com/470/47086.png";
      }
    }

    const canvas = Canvas.createCanvas(700, 250);
    const ctx = canvas.getContext("2d");

    
       Canvas.registerFont(__dirname + '/normal.ttf', {
      family: 'Manrope',
      weight: 'regular',
      style: 'normal'
  });
  Canvas.registerFont(__dirname + '/bold.ttf', {
      family: 'Manrope',
      weight: 'bold',
      style: 'normal'
  });
    const font = 'Manrope';

    if (blur) {
      const background = await jimp.read(link);

      background.blur(5);

      let mraw = await background.getBufferAsync("image/png");

      const fixedbkg = await Canvas.loadImage(mraw);

      ctx.drawImage(fixedbkg, 0, 0, canvas.width, canvas.height);
    } else {
      const fixedbkg = await Canvas.loadImage(link);

      ctx.drawImage(fixedbkg, 0, 0, canvas.width, canvas.height);
    }

    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    let blurImage = await Canvas.loadImage(
      "https://cdn.discordapp.com/attachments/735118044145123348/735477847526998077/20200722_181613.png"
    );

    ctx.drawImage(blurImage, 0, 0, canvas.width, canvas.height);
    let xname = member.user.username;

    ctx.font = `bold 36px ${font}`;
    ctx.fillStyle = "#FFFFFF";
    ctx.textAlign = "start";
    ctx.strokeStyle = "#f5f5f5";

    const name =
      xname.length > 12 ? xname.substring(0, 12).trim() + "..." : xname;
    ctx.fillText(`${name}`, 278, 113);
    ctx.strokeText(`${name}`, 278, 113);

    ctx.font = `bold 20px ${font}`;
    ctx.fillStyle = "#FFFFFF";

    ctx.fillText(`#${member.user.discriminator}`, 278, 160);

    let image = await jimp.read(
      member.user.displayAvatarURL({ format: "jpg", dynamic: true })
    );
    image.resize(1024, 1024);
    image.circle();
    let raw = await image.getBufferAsync("image/png");

    const avatar = await Canvas.loadImage(raw);
    // Draw a shape onto the main canvas
    ctx.drawImage(avatar, 72, 48, 150, 150);

    return canvas.toBuffer();
  }

  async rankcard({
    name,
    discriminator,
    currentXP,
    fullXP,
    level,
    rank,
    avatar,
    link, 
    gradiant
  } = {}) {
    
    console.log("Generating")
    if (!name) throw new Error("Please provide the name of the person");
    if (!discriminator)
      throw new Error(
        "Please provide the discriminator of permson as it is main element in rank card."
      );
    if (!currentXP)
      throw new Error(
        "Its madatory to have current xp of the person to show stats."
      );
    if (!fullXP) throw new Error("Its madatory to have Full xp number.");
    if (!level) {
      throw new Error("You did not gave Level of the person");
    }
    if (!rank) throw new Error("You did not gave Rank of the person");
    if (!avatar) throw new Error("Avatar is missing");
    if (!link) 
{   
  if(!gradiant) {
      throw new Error("Please give link of background image");
  }
}
    
    
    if(gradiant) {
      if(link) throw new Error("You can not use link and gradiant at a same time")
       let color = gradians.find(x => x.name === gradiant.toLowerCase());
        if (!color) {
          throw new Error("Invalid Color name")
        }

        link = color.link;
      
    }
    
    
    const canvas = Canvas.createCanvas(700, 250);
    const ctx = canvas.getContext("2d");

    Canvas.registerFont(__dirname + '/normal.ttf', {
      family: 'Manrope',
      weight: 'regular',
      style: 'normal'
  });
  Canvas.registerFont(__dirname + '/bold.ttf', {
      family: 'Manrope',
      weight: 'bold',
      style: 'normal'
  });
    const background = await jimp.read(link);
    const font = 'Manrope';
    background.blur(5);

    let mraw = await background.getBufferAsync("image/png");

    const fixedbkg = await Canvas.loadImage(mraw);

    ctx.drawImage(fixedbkg, 0, 0, canvas.width, canvas.height);

    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    let blurImage = await Canvas.loadImage(
      "https://cdn.discordapp.com/attachments/636154061724450826/738273549525057556/20200730_112506.png"
    );

    ctx.drawImage(blurImage, 0, 0, canvas.width, canvas.height);

    let image = await jimp.read(avatar);
    image.resize(1024, 1024);
    image.circle();
    let raw = await image.getBufferAsync("image/png");

    const profile = await Canvas.loadImage(raw);

    ctx.drawImage(profile, 44, 48, 155, 155);

    ///////////////////////////////////////////////
    ctx.font = `bold 20px ${font}`;
    ctx.fillStyle = "#FFFFFF";
    ctx.textAlign = "start";
    ctx.strokeStyle = "#f5f5f5";

    const xname =
      name.length > 18 ? name.substring(0, 18).trim() + "..." : name;
    ctx.fillText(`${name}`, 340, 52);

    ctx.font = `bold 20px ${font}`;
    ctx.fillStyle = "#FFFFFF";
    ctx.textAlign = "start";
    ctx.strokeStyle = "#f5f5f5";

    ctx.fillText(`${discriminator}`, 580, 84);

    let x = 240;
    let y = 142;
    ctx.font = `bold 22px ${font}`;
    ctx.fillStyle = "#FFFFFF";
    ctx.textAlign = "start";
    ctx.fillText(
      "/ " + change(fullXP),
      x + ctx.measureText(change(currentXP)).width + 15,
      y
    );
  
    ctx.fillText(change(currentXP), x, y);

    let converted = currentXP;
    if(typeof currentXP === "string") converted = parseInt(currentXP)
    let widthXP = (converted * 439) / fullXP;
    if (widthXP > 439 - 18.5) widthXP = 439 - 18.5
    ctx.beginPath();


    console.log(widthXP);
    ctx.fillRect(239, 119.5 + 36.25, widthXP, 23.5);
   

    const RankN = rank.length > 5 ? rank.substring(0, 5).trim() + "+" : rank;
    ctx.fillText(`${RankN}`, 310, 210);

    const levelN =
      level.length > 6 ? level.substring(0, 6).trim() + "+" : level;
    ctx.fillText(`${levelN}`, 500, 210);

    return canvas.toBuffer();
  }
}

function change(num) {
  if (!num) return "NaN";
  if (typeof num === "string") num = parseInt(num);
  let decPlaces = Math.pow(10, 1);
  var abbrev = ["K", "M", "B", "T"];
  for (var i = abbrev.length - 1; i >= 0; i--) {
    var size = Math.pow(10, (i + 1) * 3);
    if (size <= num) {
      num = Math.round((num * decPlaces) / size) / decPlaces;
      if (num == 1000 && i < abbrev.length - 1) {
        num = 1;
        i++;
      }
      num += abbrev[i];
      break;
    }
  }
  return num;
}

module.exports = CanvasSenpai;
